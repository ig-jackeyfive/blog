## V8 引擎垃圾回收

不同语言垃圾回收：

* 自动回收：Java，JavaScript，python  

  采用自己的一套垃圾回收算法进行自动的内存管理

* 手动回收：C/C++    程序员自己去开辟或者释放内存



Javascript垃圾回收：

### **栈内存**

ESP指针下移，上下文切换之后，栈顶的空间会自动被回收



### **堆内存**

V8内存分配有上限源于	**JS单线程的执行机制	**和 	**JS垃圾回收机制的限制**



堆内存又分两部分进行处理：新生代内存和老生代内存

新生代就是临时分配的内存，存活时间短， 老生代是常驻内存，存活的时间长。

#### **新生代内存**

新生代内存采用**Scavenge算法**来处理：

1. 是把新生代空间对半划分为两个区域，一半是对象区域 ，一半是空闲区域。
2. 新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。
3. 垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。
4. 完成复制后，对象区域与空闲区域进行角色翻转，对象区域和空闲互换，好处是**两块区域无限重复使用**。
5. 为了执行效率，一般新生区的空间会被设置得比较小。
6. **对象晋升策略**：经过两次垃圾回收依然还存活的对象，会被移动到老生区中。

#### 老生代内存

当

- 已经经历过一次 Scavenge 回收。
- To（闲置）空间的内存占用超过25%。

时新生代中的变量就会被放入到`老生代内存`中，这种现象就叫`晋升`—— 对象晋升策略



第一步，**进行标记-清除**。

分成两个阶段，即标记阶段和清除阶段。

标记阶段：

清除阶段：



第二步，**整理内存碎片**。

把存活的对象全部往一端靠拢。



### 增量标记

为了降低老生代的垃圾回收而造成的卡顿，V8将一口气完成的标记任务分为很多小的部分完成，同时让垃圾回收标记和JavaScript应用逻辑交替进行，直到标记阶段完成。

